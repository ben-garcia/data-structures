/*
  FILE: Bag4.template
  TEMPLATE CLASS IMPLEMENTED: Bag<Item> (see Bag4.h for documentation)
  This file should be included in the header file and not compiled serperatly.
  Because of this, we must not have any using directives in the implementation.

  INVARIANT for the Bag class:
    1. The number of items in the bag is in the member variable used.
    2. The actual items of the bag are stored in a partially fulled array.
       The array is a dynamic array, pointed to be the member variable data.
    3. The size of he dynamic array is in the member variable capacity.
 */
 #include <algorithm>   // Provides copy
 #include <cassert>     // Provides assert
 #include <cstdlib>     // Provides rand

 namespace main_savitch_6A {
   template <class Item>
   // Outside of the class definition, each definition is preceded by the template prefix.
   // Outside of the class definition, the use of Bag as a type name is changed to Bag<Item>.
   // Also, the keyword typename must precede any use of Bag<Item>::sizeType adn the valueType
   // is written as Item.
   const typename Bag<Item>::sizeType Bag<Item>::DEFAULT_CAPACITY;

   template <class Item>
   Bag<Item>::Bag(sizeType initialCapacity) {
     data = new Item[initialCapacity];
     capacity = initialCapacity;
     used = 0;
   }

   template <class Item>
   Bag<Item>::Bag(const Bag<Item>& source) {
     data = new Item[source.capacity];
     capacity = source.capacity;
     used = source.used;
     // Within the implementation file, we don't put any using directives,
     // so we must write std::copy rather than simply copy.
     std::copy(source.data, source.data + used, data);
   }

   template <class Item>
   Bag<Item>::~Bag() {
     delete[] data;
   }

   template <class Item>
   typename Bag<Item>::sizeType Bag<Item>::erase(const Item& target) {
     sizeType index = 0;
     sizeType manyRemoved = 0;

     while (index < used) {
       if (data[index] == target) {
         used--;
         data[index] = data[used];
         manyRemoved++;
       }
       else {
         index++;
       }
     }
      return manyRemoved;
   }

   template <class Item>
   bool Bag<Item>::eraseOne(const Item& target) {
     sizeType index = 0;
     while ((index < used) && (data[index] != target)) {
       index++;
     }

     if (index == used) {
       return false;
     }

     used--;
     data[index] = data[used];
     return true;
   }

   template <class Item>
   void Bag<Item>::insert(const Item& entry) {
     if (used == capacity) {
       reserve(used + 1);
     }
     data[used] = entry;
     used++;
   }

   template <class Item>
   void Bag<Item>::operator =(const Bag<Item>& source) {
     valueType *newData;

     if (this == &source) {
       return;
     }

     if (capacity != source.capacity) {
       newData = new valueType[source.capacity];
       delete[] data;
       data = newData;
       capacity = source.capacity;
     }

     used = source.used;
     std::copy(source.data, source.data + used, newData);
   }

   template <class Item>
   void Bag<Item>::operator +=(const Bag<Item>& addend) {
     if (used + addend.used > capacity) {
       reserve(used + addend.used);
     }

     std::copy(addend.data, addend.data + addend.used, data + used);
     used += addend.used;
   }

   template <class Item>
   void Bag<Item>::reserve(sizeType newCapacity) {
     valueType *largerArray;

     if (newCapacity == capacity) {
       return;
     }
     if (newCapacity < used) {
       newCapacity = used;
     }

     largerArray = new valueType[newCapacity];
     std::copy(data, data + used, largerArray);
     delete[] data;
     data = largerArray;
     capacity = newCapacity;
   }

   template <class Item>
   typename Bag<Item>::sizeType Bag<Item>::count(const Item& target) const {
     sizeType answer;
     sizeType i;

     answer = 0;
     for (i = 0; i < used; i++) {
       if (target == data[i]) {
         answer++;
       }
     }
     return answer;
   }

   template <class Item>
   Item Bag<Item>::grab() const {
     sizeType i;

     assert(size() > 0);
     i = (std::rand() % size());  // i is in the range of 0 to size() - 1.
     return data[i];
   }

   template <class Item>
   Bag<Item> operator +(const Bag<Item>& b1, const Bag<Item>& b2) {
     Bag<Item> answer(b1.size() + b2.size());

     answer += b1;
     answer += b2;
     return answer;
   }
 }
