/**
 * FILE: Graph.template (part of the namespace main_savitch_15)
 * TEMPLATE CLASS IMPLEMENTATION: Graph<Item> (See Graph.h for documentation.)
 * This file is included in the header file and not compiled separately.
 * INVARIANT for the Graph class:
 *   1. The number of vertices in the graph are stored in the member variable manyVertices.
 *      These vertices are numbered from 0 to manyVertices - 1.
 *   2. edges is the adjacency matrix for the graph (with true in edges[i][j] to indicate an
 *      edge from vertex i to vertex j).
 *   3. For each i < manyVertices, labels[i] is the label of vertex i.
 */

#include <algorithm>
#include <cassert>  // Provides assert
#include <cstdlib>  // Provides size_t
#include <queue>    // Provides queue
#include <set>      // Provides set
#include <vector>

namespace main_savitch_15 {
template <class Item>
const std::size_t Graph<Item>::MAXIMUM;

template <class Item>
void Graph<Item>::addEdge(const Item& source, const Item& target) {
  // check if the source Item is in the vector
  auto sourceIterator = std::find(labels.begin(), labels.end(), source);
  // check if the target Item is in the vecto4
  auto targetIterator = std::find(labels.begin(), labels.end(), target);
  // if the iterator points to the end
  // that means that labels vector doesn't contain source
  if (sourceIterator == labels.end()) return;
  // if the iterator points to the end
  // that means that labels vector doesn't contain target
  if (targetIterator == labels.end()) return;
  // counting the distance between the start of the labels vector
  // and the iterator is the index of the element
  // for source
  int sourceIndex = std::distance(labels.begin(), sourceIterator);
  // for target
  int targetIndex = std::distance(labels.begin(), targetIterator);
  // set the cell in the matrix to indicate there is an edge
  // between source and target
  edges[sourceIndex][targetIndex] = true;
}

template <class Item>
void Graph<Item>::addVertex(const Item& label) {
  std::size_t newVertexNumber;
  std::size_t otherNumber;

  assert(size() < MAXIMUM);
  newVertexNumber = manyVertices;
  ++manyVertices;

  for (otherNumber = 0; otherNumber < manyVertices; ++otherNumber) {
    edges[otherNumber][newVertexNumber] = false;
    edges[newVertexNumber][otherNumber] = false;
  }
  // add the new vertex to the labels vector
  labels.push_back(label);
}

template <class Item>
bool Graph<Item>::isEdge(const Item& source, const Item& target) const {
  auto sourceIterator = std::find(labels.begin(), labels.end(), source);
  auto targetIterator = std::find(labels.begin(), labels.end(), target);
  if (sourceIterator == labels.end()) return false;
  if (targetIterator == labels.end()) return false;
  int sourceIndex = std::distance(labels.begin(), sourceIterator);
  int targetIndex = std::distance(labels.begin(), targetIterator);

  return edges[sourceIndex][targetIndex];
}

template <class Item>
Item& Graph<Item>::operator[](std::size_t vertex) {
  assert(vertex < size());
  return labels[vertex];  // Returns a reference to the label.
}

template <class Item>
Item Graph<Item>::operator[](std::size_t vertex) const {
  assert(vertex < size());
  return labels[vertex];  // Returns only a copy of the label.
}

template <class Item>
std::set<std::size_t> Graph<Item>::neighbors(std::size_t vertex) const {
  std::set<std::size_t> answer;
  std::size_t i;

  assert(vertex < size());

  for (i = 0; i < size(); ++i) {
    if (edges[vertex][i]) {
      answer.insert(i);
    }
  }
  return answer;
}

template <class Item>
void Graph<Item>::removeEdge(std::size_t source, std::size_t target) {
  assert(source < size());
  assert(target < size());
  edges[source][target] = false;
}

// Graph Traversal Algorithms
template <class Process, class Item, class SizeType>
void rec_dfs(Process f, Graph<Item>& g, SizeType v, bool marked[]) {
  // Precondition: g is a labeled graph that is being traversed by a depth-first search. For each
  // vertex x, marked[x] is true if x has already been visited by this search, otherwise marked[x]
  // is false. The vertex v is an unmarked vertex that the search has just arrived at.
  // Postcondition: The depth-first search of g has been continued through vertex v and beyond
  // to all the vertices that can be reached from v via a path of unmarked vertices. The function
  // f has been applied to the label of each vertex visited by the search, and each such vertex x
  // has also been marked by setting marked[x] to true.
  // Library facilities used: cstdlib, graph.h, set
  std::set<std::size_t> connections = g.neighbors(v);
  std::set<std::size_t>::iterator it;
  marked[v] = true;
  f(g[v]);
  // Mark vertex v.
  // Process the label of vertex v with the function f.
  // Traverse all the neighbors, looking for unmarked vertices:
  for (it = connections.begin(); it != connections.end(); ++it) {
    if (!marked[*it])
      rec_dfs(f, g, *it, marked);
  }
}

template <class Process, class Item, class SizeType>
void depth_first(Process f, Graph<Item>& g, SizeType start) {
  // Precondition: start is a vertex number of the labeled graph g.
  // Postcondition: A depth-first search of g has been executed, starting at the start vertex.
  // The function f has been applied to the label of each vertex visited by the search.
  // Library facilities used: algorithm, cassert, graph.h
  bool marked[g.MAXIMUM];
  assert(start < g.size());
  std::fill_n(marked, g.size(), false);
  rec_dfs(f, g, start, marked);
}

template <class Process, class Item, class SizeType>
void breadth_first(Process f, Graph<Item>& g, SizeType start) {
  // Same as the depth_first function, but using a breadth-first search instead
  // Library facilities used: algorithm, cassert, cstdlib, graph.h, queue
  bool marked[g.MAXIMUM];
  std::set<std::size_t> connections;
  std::set<std::size_t>::iterator it;
  std::queue<std::size_t> vertex_queue;
  assert(start < g.size());
  std::fill_n(marked, g.size(), false);
  marked[start] = true;
  f(g[start]);
  vertex_queue.push(start);
  do {
    connections = g.neighbors(vertex_queue.front());
    vertex_queue.pop();
    // Mark and process the unmarked neighbors, and place them in the queue.
    for (it = connections.begin(); it != connections.end(); ++it) {
      if (!marked[*it]) {
        marked[*it] = true;
        f(g[*it]);
        vertex_queue.push(*it);
      }
    }
  } while (!vertex_queue.empty());
}

}  // namespace main_savitch_15